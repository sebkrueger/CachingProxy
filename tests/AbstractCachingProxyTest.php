<?php/** * This file is part of secra/CachingProxy. * * (c) Sebastian Krüger <krueger@secra.de> * * For the full copyright and license information, please view the LICENSE * file that was distributed with this source code. */namespace secra\CachingProxy\Tests;use org\bovigo\vfs\vfsStream;use secra\CachingProxy\AbstractCachingProxyTestClass;// include Testclassrequire_once 'AbstractCachingProxyTestClass.php';/** * CachingProxyTest * * @category test * @package de.secra.cachingproxy * @author Sebastian Krüger <krueger@secra.de> * @copyright 2014 Sebastian Krüger * @license http://www.opensource.org/licenses/MIT The MIT License */class AbstractCachingProxyTest extends \PHPUnit_Framework_TestCase{    /*     * @type AbstractCachingProxy    */    private $cachingproxystub;    /*     * @type vfsStreamDirectory    */    protected $vfsroot;    /*     *     * $testStreamUrl=vfsStream::url('testdir');     * $object->doSomethingWithFileSystem($testStreamUrl);     * $this->assertTrue($testStream->hasChild('new-file.txt');     */    public function setUp()    {        // Set vfs Testfilesystem        $this->vfsroot = vfsStream::setup('testdir');        // instanciate teststub class for abstract class        $this->cachingproxystub = new AbstractCachingProxyTestClass("/","cache");    }    // TODO: Check how function addFile and getIncludeFileset can test without inferences    /**     * @test     * @covers secra\CachingProxy\AbstractCachingProxy::addFile()     */    public function testAddFile()    {        // TODO: Test intern files        // Add Files with different protocol definations        $this->cachingproxystub->addFile("https://maps.googleapis.com/maps/api/js?key=YOUR_API_KEY&sensor=FALSE");        $this->cachingproxystub->addFile("http://maps.googleapis.com/maps/api/js?key=YOUR_API_KEY&sensor=FALSE");        $this->cachingproxystub->addFile("//maps.googleapis.com/maps/api/js?key=YOUR_API_KEY&sensor=FALSE");        // retrun all extern files        $fileset = $this->cachingproxystub->getIncludeFileset();        // count the list of files        $this->assertCount(3, $fileset);    }    /**     * @test     * @covers secra\Cachingproxy\AbstractCachingProxy::addFile()     * @covers secra\Cachingproxy\AbstractCachingProxy::getIncludeFileset()     * @covers secra\CachingProxy\AbstractCachingProxy::getCacheFile()     */    public function testGetIncludeFilesets()    {        // TODO: Test Intern files        // Add nothing and get emty list        $fileset = $this->cachingproxystub->getIncludeFileset();        $this->assertCount(0, $fileset);        // Add Files with different protocol definations        $urllist = array();        $urllist[] = "https://maps.googleapis.com/maps/api/js?key=YOUR_API_KEY0&sensor=FALSE";        $urllist[] = "http://maps.googleapis.com/maps/api/js?key=YOUR_API_KEY1&sensor=FALSE";        $urllist[] = "//maps.googleapis.com/maps/api/js?key=YOUR_API_KEY2&sensor=FALSE";        foreach($urllist as $url) {            $this->cachingproxystub->addFile($url);        }        $fileset = $this->cachingproxystub->getIncludeFileset();        // See if count fitts first        $this->assertCount(3, $fileset);        // See if we get them back by url string        foreach($urllist as $url) {            $this->assertContains($url, $fileset);        }    }    /**     * @test     * @covers secra\Cachingproxy\AbstractCachingProxy::makeAbsolutPath()     */    public function testMakeAbsolutPath()    {        // Build reflection of private Function        $method = new \ReflectionMethod('\secra\CachingProxy\AbstractCachingProxyTestClass', 'makeAbsolutPath');        $method->setAccessible(true);        // realpath shouldt return false on non existing path        $this->assertFalse($method->invoke(new AbstractCachingProxyTestClass("/","cache"), "/this/path/not/exits"));        // the root path should exist on every unix based system        // TODO: make this test work on every system        //$this->assertEquals("/", $method->invoke(new \secra\CachingProxy\AbstractCachingProxyTestClass('/dev/null'), "/"));        //$this->assertEquals("/", $method->invoke(new \secra\CachingProxy\AbstractCachingProxyTestClass('/dev/null'), "//"));    }    /**     * @test     * @covers secra\Cachingproxy\AbstractCachingProxy::makeMinifiPath()     */    public function testMakeMinifiPath()    {        // Build reflection of private Function        $method = new \ReflectionMethod('\secra\CachingProxy\AbstractCachingProxyTestClass', 'makeMinifiPath');        $method->setAccessible(true);        $testpath = "/var/www/htdocs/css/file.css";        $this->assertEquals("/var/www/htdocs/css/file.min.css", $method->invoke(new AbstractCachingProxyTestClass('/','cache'), $testpath));        $testpath = "/var/www/htdocs/css/file.js";        $this->assertEquals("/var/www/htdocs/css/file.min.js", $method->invoke(new AbstractCachingProxyTestClass('/','cache'), $testpath));        $testpath = "/var/www/htdocs/css/here.is.a.js";        $this->assertEquals("/var/www/htdocs/css/here.is.a.min.js", $method->invoke(new AbstractCachingProxyTestClass('/','cache'), $testpath));        $testpath = "/var/www/htdocs/css/file..js";        $this->assertEquals("/var/www/htdocs/css/file..min.js", $method->invoke(new AbstractCachingProxyTestClass('/','cache'), $testpath));    }}